/**
 * Checkpoint Manifest Schema
 *
 * Defines TypeScript interfaces and Zod validation schemas for the checkpoint system.
 * Checkpoints enable research resume capability by capturing:
 * - Session and execution state metadata
 * - Notebook cell reference for the checkpoint marker
 * - Python environment for reproducibility
 * - Artifact locations with integrity checksums
 * - Rehydration configuration for state restoration
 *
 * Storage Location:
 * ```
 * reports/{reportTitle}/checkpoints/{runId}/{checkpointId}/
 * ├── checkpoint.json    # This manifest
 * └── artifacts/         # Checkpoint artifacts
 * ```
 *
 * @see docs/stage-protocol.md for stage and checkpoint protocol
 * @module checkpoint-schema
 */
import { z } from "zod";
/**
 * Rehydration mode determines how state is restored from a checkpoint.
 *
 * - `artifacts_only`: Load artifacts from disk (recommended, more robust)
 * - `with_vars`: Attempt to restore Python variables (experimental, may fail)
 */
export type RehydrationMode = "artifacts_only" | "with_vars";
/**
 * Checkpoint status indicates how the checkpoint was created.
 *
 * - `saved`: Normal checkpoint at stage boundary
 * - `interrupted`: Stage was interrupted (soft timeout, manual abort)
 * - `emergency`: Watchdog-triggered emergency checkpoint
 */
export type CheckpointStatus = "saved" | "interrupted" | "emergency";
/**
 * Trust level for checkpoint security validation.
 *
 * - `local`: Created by this system in the current project (default, trusted)
 * - `imported`: Copied from another project or shared (moderate trust, extra validation)
 * - `untrusted`: From external/unknown source (strict validation, user confirmation required)
 */
export type TrustLevel = "local" | "imported" | "untrusted";
/**
 * Reason for emergency checkpoint creation.
 * Only populated when status is 'emergency'.
 *
 * - `timeout`: Watchdog timeout exceeded
 * - `abort`: Manual abort requested
 * - `error`: Unhandled error during stage execution
 */
export type EmergencyReason = "timeout" | "abort" | "error";
/**
 * Metadata for a single artifact included in the checkpoint.
 * Artifacts are files produced by stages that need to be preserved for resume.
 */
export interface ArtifactEntry {
    /** Relative path from project root to the artifact file */
    relativePath: string;
    /** SHA256 hash of the artifact content for integrity verification */
    sha256: string;
    /** Size of the artifact in bytes */
    sizeBytes: number;
}
/**
 * Reference to the notebook cell containing the checkpoint marker.
 * Used to locate the checkpoint position within the research notebook.
 */
export interface NotebookReference {
    /** Path to the notebook file (relative to project root) */
    path: string;
    /** Unique cell ID where the checkpoint marker was emitted */
    checkpointCellId: string;
}
/**
 * Python environment metadata captured at checkpoint time.
 * Enables verification that resume environment matches checkpoint environment.
 */
export interface PythonEnvMetadata {
    /** Path to the Python interpreter used */
    pythonPath: string;
    /** List of installed packages with versions (format: "package==version") */
    packages: string[];
    /** Operating system platform (e.g., "linux", "darwin", "win32") */
    platform: string;
    /**
     * Random seeds captured at checkpoint time for reproducibility.
     * Keys are the module names (e.g., "random", "numpy"), values are the seed values.
     */
    randomSeeds?: Record<string, number>;
}
/**
 * Configuration for restoring state from a checkpoint.
 * Defines how the checkpoint should be rehydrated on resume.
 */
export interface RehydrationConfig {
    /**
     * Rehydration mode:
     * - `artifacts_only`: Load artifacts from disk (recommended)
     * - `with_vars`: Restore Python variables (experimental)
     */
    mode: RehydrationMode;
    /**
     * Python code lines to execute for rehydration.
     * Generated by checkpoint-manager based on artifacts and mode.
     * Example: ["import pandas as pd", "df = pd.read_parquet('...')"]
     */
    rehydrationCellSource: string[];
}
/**
 * Complete checkpoint manifest stored as checkpoint.json.
 *
 * This manifest contains all metadata needed to:
 * 1. Identify the checkpoint (checkpointId, runId, stageId)
 * 2. Locate artifacts and verify integrity (artifacts array, sha256)
 * 3. Verify environment compatibility (pythonEnv)
 * 4. Generate rehydration code (rehydration config)
 * 5. Verify manifest integrity (manifestSha256)
 *
 * @example
 * ```json
 * {
 *   "checkpointId": "ckpt-001",
 *   "researchSessionID": "ses_abc123",
 *   "reportTitle": "customer-churn-analysis",
 *   "runId": "run-001",
 *   "stageId": "S02_eda",
 *   "createdAt": "2026-01-02T10:30:00Z",
 *   "executionCount": 5,
 *   "status": "saved",
 *   "notebook": {
 *     "path": "notebooks/customer-churn-analysis.ipynb",
 *     "checkpointCellId": "cell-abc123"
 *   },
 *   "pythonEnv": {
 *     "pythonPath": "/project/.venv/bin/python",
 *     "packages": ["pandas==2.0.0", "numpy==1.24.0"],
 *     "platform": "linux"
 *   },
 *   "artifacts": [
 *     {
 *       "relativePath": "reports/customer-churn-analysis/run-001/S02_eda/df_clean.parquet",
 *       "sha256": "abc123...",
 *       "sizeBytes": 1024000
 *     }
 *   ],
 *   "rehydration": {
 *     "mode": "artifacts_only",
 *     "rehydrationCellSource": ["import pandas as pd", "df = pd.read_parquet(...)"]
 *   },
 *   "manifestSha256": "def456..."
 * }
 * ```
 */
export interface CheckpointManifest {
    /** Unique identifier for this checkpoint (e.g., "ckpt-001") */
    checkpointId: string;
    /** Research session ID that owns this checkpoint */
    researchSessionID: string;
    /** Report title / research project name */
    reportTitle: string;
    /** Run identifier within the research project */
    runId: string;
    /** Stage ID this checkpoint was created after (e.g., "S02_eda") */
    stageId: string;
    /** ISO 8601 timestamp when checkpoint was created */
    createdAt: string;
    /** REPL execution count at checkpoint time */
    executionCount: number;
    /** How the checkpoint was created: saved, interrupted, or emergency */
    status: CheckpointStatus;
    /** Reason for emergency checkpoint (only when status is 'emergency') */
    reason?: EmergencyReason;
    /** Trust level for security validation (default: local) */
    trustLevel?: TrustLevel;
    /** Reference to the notebook and cell containing checkpoint marker */
    notebook: NotebookReference;
    /** Python environment metadata for reproducibility verification */
    pythonEnv: PythonEnvMetadata;
    /** Array of artifact entries with paths and integrity hashes */
    artifacts: ArtifactEntry[];
    /** Configuration for restoring state from this checkpoint */
    rehydration: RehydrationConfig;
    /**
     * SHA256 hash of the manifest content (excluding this field).
     * Used to verify manifest integrity on load.
     */
    manifestSha256: string;
}
/**
 * Zod schema for RehydrationMode enum.
 */
export declare const RehydrationModeSchema: z.ZodEnum<{
    artifacts_only: "artifacts_only";
    with_vars: "with_vars";
}>;
/**
 * Zod schema for CheckpointStatus enum.
 */
export declare const CheckpointStatusSchema: z.ZodEnum<{
    interrupted: "interrupted";
    emergency: "emergency";
    saved: "saved";
}>;
/**
 * Zod schema for EmergencyReason enum.
 */
export declare const EmergencyReasonSchema: z.ZodEnum<{
    error: "error";
    timeout: "timeout";
    abort: "abort";
}>;
/**
 * Zod schema for TrustLevel enum.
 */
export declare const TrustLevelSchema: z.ZodEnum<{
    local: "local";
    imported: "imported";
    untrusted: "untrusted";
}>;
/**
 * Zod schema for ArtifactEntry.
 */
export declare const ArtifactEntrySchema: z.ZodObject<{
    relativePath: z.ZodString;
    sha256: z.ZodString;
    sizeBytes: z.ZodNumber;
}, z.core.$strip>;
/**
 * Zod schema for NotebookReference.
 */
export declare const NotebookReferenceSchema: z.ZodObject<{
    path: z.ZodString;
    checkpointCellId: z.ZodString;
}, z.core.$strip>;
/**
 * Zod schema for PythonEnvMetadata.
 */
export declare const PythonEnvMetadataSchema: z.ZodObject<{
    pythonPath: z.ZodString;
    packages: z.ZodArray<z.ZodString>;
    platform: z.ZodString;
    randomSeeds: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodNumber>>;
}, z.core.$strip>;
/**
 * Zod schema for RehydrationConfig.
 */
export declare const RehydrationConfigSchema: z.ZodObject<{
    mode: z.ZodEnum<{
        artifacts_only: "artifacts_only";
        with_vars: "with_vars";
    }>;
    rehydrationCellSource: z.ZodArray<z.ZodString>;
}, z.core.$strip>;
/**
 * Zod schema for CheckpointManifest.
 * Validates all fields including conditional requirements.
 */
export declare const CheckpointManifestSchema: z.ZodObject<{
    checkpointId: z.ZodString;
    researchSessionID: z.ZodString;
    reportTitle: z.ZodString;
    runId: z.ZodString;
    stageId: z.ZodString;
    createdAt: z.ZodISODateTime;
    executionCount: z.ZodNumber;
    status: z.ZodEnum<{
        interrupted: "interrupted";
        emergency: "emergency";
        saved: "saved";
    }>;
    reason: z.ZodOptional<z.ZodEnum<{
        error: "error";
        timeout: "timeout";
        abort: "abort";
    }>>;
    trustLevel: z.ZodDefault<z.ZodOptional<z.ZodEnum<{
        local: "local";
        imported: "imported";
        untrusted: "untrusted";
    }>>>;
    notebook: z.ZodObject<{
        path: z.ZodString;
        checkpointCellId: z.ZodString;
    }, z.core.$strip>;
    pythonEnv: z.ZodObject<{
        pythonPath: z.ZodString;
        packages: z.ZodArray<z.ZodString>;
        platform: z.ZodString;
        randomSeeds: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodNumber>>;
    }, z.core.$strip>;
    artifacts: z.ZodArray<z.ZodObject<{
        relativePath: z.ZodString;
        sha256: z.ZodString;
        sizeBytes: z.ZodNumber;
    }, z.core.$strip>>;
    rehydration: z.ZodObject<{
        mode: z.ZodEnum<{
            artifacts_only: "artifacts_only";
            with_vars: "with_vars";
        }>;
        rehydrationCellSource: z.ZodArray<z.ZodString>;
    }, z.core.$strip>;
    manifestSha256: z.ZodString;
}, z.core.$strip>;
/**
 * Inferred TypeScript type from the CheckpointManifest Zod schema.
 * Use this when you want the exact type that Zod validates.
 */
export type CheckpointManifestInput = z.input<typeof CheckpointManifestSchema>;
/**
 * Validated output type from the CheckpointManifest Zod schema.
 */
export type CheckpointManifestOutput = z.output<typeof CheckpointManifestSchema>;
/**
 * Validate a checkpoint manifest object.
 *
 * @param manifest - The manifest object to validate
 * @returns Validation result with success/error information
 *
 * @example
 * ```typescript
 * const result = validateCheckpointManifest(manifestData);
 * if (result.success) {
 *   console.log("Valid manifest:", result.data);
 * } else {
 *   console.error("Validation errors:", result.error.issues);
 * }
 * ```
 */
export declare function validateCheckpointManifest(manifest: unknown): z.SafeParseReturnType<CheckpointManifestInput, CheckpointManifestOutput>;
/**
 * Parse and validate a checkpoint manifest, throwing on error.
 *
 * @param manifest - The manifest object to validate
 * @returns The validated manifest
 * @throws ZodError if validation fails
 *
 * @example
 * ```typescript
 * try {
 *   const validated = parseCheckpointManifest(manifestData);
 *   // validated is guaranteed to be valid
 * } catch (error) {
 *   console.error("Invalid manifest:", error);
 * }
 * ```
 */
export declare function parseCheckpointManifest(manifest: unknown): CheckpointManifest;
/**
 * Create a partial checkpoint manifest for building incrementally.
 * Useful when constructing a manifest step by step.
 *
 * @returns A Zod schema that allows partial fields
 */
export declare function createPartialCheckpointManifestSchema(): z.ZodObject<{
    checkpointId: z.ZodOptional<z.ZodString>;
    researchSessionID: z.ZodOptional<z.ZodString>;
    reportTitle: z.ZodOptional<z.ZodString>;
    runId: z.ZodOptional<z.ZodString>;
    stageId: z.ZodOptional<z.ZodString>;
    createdAt: z.ZodOptional<z.ZodISODateTime>;
    executionCount: z.ZodOptional<z.ZodNumber>;
    status: z.ZodOptional<z.ZodEnum<{
        interrupted: "interrupted";
        emergency: "emergency";
        saved: "saved";
    }>>;
    reason: z.ZodOptional<z.ZodOptional<z.ZodEnum<{
        error: "error";
        timeout: "timeout";
        abort: "abort";
    }>>>;
    trustLevel: z.ZodOptional<z.ZodDefault<z.ZodOptional<z.ZodEnum<{
        local: "local";
        imported: "imported";
        untrusted: "untrusted";
    }>>>>;
    notebook: z.ZodOptional<z.ZodObject<{
        path: z.ZodString;
        checkpointCellId: z.ZodString;
    }, z.core.$strip>>;
    pythonEnv: z.ZodOptional<z.ZodObject<{
        pythonPath: z.ZodString;
        packages: z.ZodArray<z.ZodString>;
        platform: z.ZodString;
        randomSeeds: z.ZodOptional<z.ZodRecord<z.ZodString, z.ZodNumber>>;
    }, z.core.$strip>>;
    artifacts: z.ZodOptional<z.ZodArray<z.ZodObject<{
        relativePath: z.ZodString;
        sha256: z.ZodString;
        sizeBytes: z.ZodNumber;
    }, z.core.$strip>>>;
    rehydration: z.ZodOptional<z.ZodObject<{
        mode: z.ZodEnum<{
            artifacts_only: "artifacts_only";
            with_vars: "with_vars";
        }>;
        rehydrationCellSource: z.ZodArray<z.ZodString>;
    }, z.core.$strip>>;
    manifestSha256: z.ZodOptional<z.ZodString>;
}, z.core.$strip>;
