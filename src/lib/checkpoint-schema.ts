/**
 * Checkpoint Manifest Schema
 *
 * Defines TypeScript interfaces and Zod validation schemas for the checkpoint system.
 * Checkpoints enable research resume capability by capturing:
 * - Session and execution state metadata
 * - Notebook cell reference for the checkpoint marker
 * - Python environment for reproducibility
 * - Artifact locations with integrity checksums
 * - Rehydration configuration for state restoration
 *
 * Storage Location:
 * ```
 * reports/{reportTitle}/checkpoints/{runId}/{checkpointId}/
 * ├── checkpoint.json    # This manifest
 * └── artifacts/         # Checkpoint artifacts
 * ```
 *
 * @see docs/stage-protocol.md for stage and checkpoint protocol
 * @module checkpoint-schema
 */

import { z } from "zod";

// =============================================================================
// ENUM TYPES
// =============================================================================

/**
 * Rehydration mode determines how state is restored from a checkpoint.
 *
 * - `artifacts_only`: Load artifacts from disk (recommended, more robust)
 * - `with_vars`: Attempt to restore Python variables (experimental, may fail)
 */
export type RehydrationMode = "artifacts_only" | "with_vars";

/**
 * Checkpoint status indicates how the checkpoint was created.
 *
 * - `saved`: Normal checkpoint at stage boundary
 * - `interrupted`: Stage was interrupted (soft timeout, manual abort)
 * - `emergency`: Watchdog-triggered emergency checkpoint
 */
export type CheckpointStatus = "saved" | "interrupted" | "emergency";

/**
 * Trust level for checkpoint security validation.
 *
 * - `local`: Created by this system in the current project (default, trusted)
 * - `imported`: Copied from another project or shared (moderate trust, extra validation)
 * - `untrusted`: From external/unknown source (strict validation, user confirmation required)
 */
export type TrustLevel = "local" | "imported" | "untrusted";

/**
 * Reason for emergency checkpoint creation.
 * Only populated when status is 'emergency'.
 *
 * - `timeout`: Watchdog timeout exceeded
 * - `abort`: Manual abort requested
 * - `error`: Unhandled error during stage execution
 */
export type EmergencyReason = "timeout" | "abort" | "error";

// =============================================================================
// COMPONENT INTERFACES
// =============================================================================

/**
 * Metadata for a single artifact included in the checkpoint.
 * Artifacts are files produced by stages that need to be preserved for resume.
 */
export interface ArtifactEntry {
  /** Relative path from project root to the artifact file */
  relativePath: string;

  /** SHA256 hash of the artifact content for integrity verification */
  sha256: string;

  /** Size of the artifact in bytes */
  sizeBytes: number;
}

/**
 * Reference to the notebook cell containing the checkpoint marker.
 * Used to locate the checkpoint position within the research notebook.
 */
export interface NotebookReference {
  /** Path to the notebook file (relative to project root) */
  path: string;

  /** Unique cell ID where the checkpoint marker was emitted */
  checkpointCellId: string;
}

/**
 * Python environment metadata captured at checkpoint time.
 * Enables verification that resume environment matches checkpoint environment.
 */
export interface PythonEnvMetadata {
  /** Path to the Python interpreter used */
  pythonPath: string;

  /** List of installed packages with versions (format: "package==version") */
  packages: string[];

  /** Operating system platform (e.g., "linux", "darwin", "win32") */
  platform: string;

  /**
   * Random seeds captured at checkpoint time for reproducibility.
   * Keys are the module names (e.g., "random", "numpy"), values are the seed values.
   */
  randomSeeds?: Record<string, number>;
}

/**
 * Configuration for restoring state from a checkpoint.
 * Defines how the checkpoint should be rehydrated on resume.
 */
export interface RehydrationConfig {
  /**
   * Rehydration mode:
   * - `artifacts_only`: Load artifacts from disk (recommended)
   * - `with_vars`: Restore Python variables (experimental)
   */
  mode: RehydrationMode;

  /**
   * Python code lines to execute for rehydration.
   * Generated by checkpoint-manager based on artifacts and mode.
   * Example: ["import pandas as pd", "df = pd.read_parquet('...')"]
   */
  rehydrationCellSource: string[];
}

// =============================================================================
// MAIN CHECKPOINT MANIFEST INTERFACE
// =============================================================================

/**
 * Complete checkpoint manifest stored as checkpoint.json.
 *
 * This manifest contains all metadata needed to:
 * 1. Identify the checkpoint (checkpointId, runId, stageId)
 * 2. Locate artifacts and verify integrity (artifacts array, sha256)
 * 3. Verify environment compatibility (pythonEnv)
 * 4. Generate rehydration code (rehydration config)
 * 5. Verify manifest integrity (manifestSha256)
 *
 * @example
 * ```json
 * {
 *   "checkpointId": "ckpt-001",
 *   "researchSessionID": "ses_abc123",
 *   "reportTitle": "customer-churn-analysis",
 *   "runId": "run-001",
 *   "stageId": "S02_eda",
 *   "createdAt": "2026-01-02T10:30:00Z",
 *   "executionCount": 5,
 *   "status": "saved",
 *   "notebook": {
 *     "path": "notebooks/customer-churn-analysis.ipynb",
 *     "checkpointCellId": "cell-abc123"
 *   },
 *   "pythonEnv": {
 *     "pythonPath": "/project/.venv/bin/python",
 *     "packages": ["pandas==2.0.0", "numpy==1.24.0"],
 *     "platform": "linux"
 *   },
 *   "artifacts": [
 *     {
 *       "relativePath": "reports/customer-churn-analysis/run-001/S02_eda/df_clean.parquet",
 *       "sha256": "abc123...",
 *       "sizeBytes": 1024000
 *     }
 *   ],
 *   "rehydration": {
 *     "mode": "artifacts_only",
 *     "rehydrationCellSource": ["import pandas as pd", "df = pd.read_parquet(...)"]
 *   },
 *   "manifestSha256": "def456..."
 * }
 * ```
 */
export interface CheckpointManifest {
  // ─────────────────────────────────────────────────────────────────────────
  // Identification Fields (2.2.2)
  // ─────────────────────────────────────────────────────────────────────────

  /** Unique identifier for this checkpoint (e.g., "ckpt-001") */
  checkpointId: string;

  /** Research session ID that owns this checkpoint */
  researchSessionID: string;

  /** Report title / research project name */
  reportTitle: string;

  /** Run identifier within the research project */
  runId: string;

  /** Stage ID this checkpoint was created after (e.g., "S02_eda") */
  stageId: string;

  // ─────────────────────────────────────────────────────────────────────────
  // Timing Fields (2.2.3)
  // ─────────────────────────────────────────────────────────────────────────

  /** ISO 8601 timestamp when checkpoint was created */
  createdAt: string;

  /** REPL execution count at checkpoint time */
  executionCount: number;

  // ─────────────────────────────────────────────────────────────────────────
  // Status Fields
  // ─────────────────────────────────────────────────────────────────────────

  /** How the checkpoint was created: saved, interrupted, or emergency */
  status: CheckpointStatus;

  /** Reason for emergency checkpoint (only when status is 'emergency') */
  reason?: EmergencyReason;

  /** Trust level for security validation (default: local) */
  trustLevel?: TrustLevel;

  // ─────────────────────────────────────────────────────────────────────────
  // Notebook Reference (2.2.4)
  // ─────────────────────────────────────────────────────────────────────────

  /** Reference to the notebook and cell containing checkpoint marker */
  notebook: NotebookReference;

  // ─────────────────────────────────────────────────────────────────────────
  // Python Environment (2.2.5)
  // ─────────────────────────────────────────────────────────────────────────

  /** Python environment metadata for reproducibility verification */
  pythonEnv: PythonEnvMetadata;

  // ─────────────────────────────────────────────────────────────────────────
  // Artifacts (2.2.6)
  // ─────────────────────────────────────────────────────────────────────────

  /** Array of artifact entries with paths and integrity hashes */
  artifacts: ArtifactEntry[];

  // ─────────────────────────────────────────────────────────────────────────
  // Rehydration Config (2.2.7)
  // ─────────────────────────────────────────────────────────────────────────

  /** Configuration for restoring state from this checkpoint */
  rehydration: RehydrationConfig;

  // ─────────────────────────────────────────────────────────────────────────
  // Integrity (2.2.8)
  // ─────────────────────────────────────────────────────────────────────────

  /**
   * SHA256 hash of the manifest content (excluding this field).
   * Used to verify manifest integrity on load.
   */
  manifestSha256: string;
}

// =============================================================================
// ZOD VALIDATION SCHEMAS (2.2.9)
// =============================================================================

/**
 * Zod schema for RehydrationMode enum.
 */
export const RehydrationModeSchema = z.enum(["artifacts_only", "with_vars"]);

/**
 * Zod schema for CheckpointStatus enum.
 */
export const CheckpointStatusSchema = z.enum(["saved", "interrupted", "emergency"]);

/**
 * Zod schema for EmergencyReason enum.
 */
export const EmergencyReasonSchema = z.enum(["timeout", "abort", "error"]);

/**
 * Zod schema for TrustLevel enum.
 */
export const TrustLevelSchema = z.enum(["local", "imported", "untrusted"]);

/**
 * Zod schema for ArtifactEntry.
 */
export const ArtifactEntrySchema = z.object({
  relativePath: z.string().min(1, "Artifact path cannot be empty"),
  sha256: z.string().regex(/^[a-f0-9]{64}$/i, "Invalid SHA256 hash format"),
  sizeBytes: z.number().int().nonnegative("Size must be a non-negative integer"),
});

/**
 * Zod schema for NotebookReference.
 */
export const NotebookReferenceSchema = z.object({
  path: z.string().min(1, "Notebook path cannot be empty"),
  checkpointCellId: z.string().min(1, "Cell ID cannot be empty"),
});

/**
 * Zod schema for PythonEnvMetadata.
 */
export const PythonEnvMetadataSchema = z.object({
  pythonPath: z.string().min(1, "Python path cannot be empty"),
  packages: z.array(z.string()),
  platform: z.string().min(1, "Platform cannot be empty"),
  randomSeeds: z.record(z.string(), z.number()).optional(),
});

/**
 * Zod schema for RehydrationConfig.
 */
export const RehydrationConfigSchema = z.object({
  mode: RehydrationModeSchema,
  rehydrationCellSource: z.array(z.string()),
});

/**
 * Zod schema for CheckpointManifest.
 * Validates all fields including conditional requirements.
 */
export const CheckpointManifestSchema = z
  .object({
    // Identification Fields
    checkpointId: z.string().min(1, "Checkpoint ID cannot be empty"),
    researchSessionID: z.string().min(1, "Research session ID cannot be empty"),
    reportTitle: z.string().min(1, "Report title cannot be empty"),
    runId: z.string().min(1, "Run ID cannot be empty"),
    stageId: z
      .string()
      .regex(
        /^S[0-9]{2}_[a-z]+_[a-z_]+$/,
        "Stage ID must follow format S{NN}_{verb}_{noun}"
      ),

    // Timing Fields
    createdAt: z.string().datetime({ message: "Invalid ISO 8601 datetime format" }),
    executionCount: z.number().int().nonnegative("Execution count must be non-negative"),

    // Status Fields
    status: CheckpointStatusSchema,
    reason: EmergencyReasonSchema.optional(),
    trustLevel: TrustLevelSchema.optional().default("local"),

    // Notebook Reference
    notebook: NotebookReferenceSchema,

    // Python Environment
    pythonEnv: PythonEnvMetadataSchema,

    // Artifacts
    artifacts: z.array(ArtifactEntrySchema),

    // Rehydration Config
    rehydration: RehydrationConfigSchema,

    // Integrity
    manifestSha256: z
      .string()
      .regex(/^[a-f0-9]{64}$/i, "Invalid manifest SHA256 hash format"),
  })
  .refine(
    (data) => {
      // Emergency checkpoints must have a reason
      if (data.status === "emergency" && !data.reason) {
        return false;
      }
      return true;
    },
    {
      message: "Emergency checkpoints must include a reason",
      path: ["reason"],
    }
  );

// =============================================================================
// TYPE EXPORTS FROM ZOD SCHEMAS
// =============================================================================

/**
 * Inferred TypeScript type from the CheckpointManifest Zod schema.
 * Use this when you want the exact type that Zod validates.
 */
export type CheckpointManifestInput = z.input<typeof CheckpointManifestSchema>;

/**
 * Validated output type from the CheckpointManifest Zod schema.
 */
export type CheckpointManifestOutput = z.output<typeof CheckpointManifestSchema>;

// =============================================================================
// VALIDATION HELPER FUNCTIONS
// =============================================================================

/**
 * Validate a checkpoint manifest object.
 *
 * @param manifest - The manifest object to validate
 * @returns Validation result with success/error information
 *
 * @example
 * ```typescript
 * const result = validateCheckpointManifest(manifestData);
 * if (result.success) {
 *   console.log("Valid manifest:", result.data);
 * } else {
 *   console.error("Validation errors:", result.error.issues);
 * }
 * ```
 */
export function validateCheckpointManifest(
  manifest: unknown
): z.SafeParseReturnType<CheckpointManifestInput, CheckpointManifestOutput> {
  return CheckpointManifestSchema.safeParse(manifest);
}

/**
 * Parse and validate a checkpoint manifest, throwing on error.
 *
 * @param manifest - The manifest object to validate
 * @returns The validated manifest
 * @throws ZodError if validation fails
 *
 * @example
 * ```typescript
 * try {
 *   const validated = parseCheckpointManifest(manifestData);
 *   // validated is guaranteed to be valid
 * } catch (error) {
 *   console.error("Invalid manifest:", error);
 * }
 * ```
 */
export function parseCheckpointManifest(manifest: unknown): CheckpointManifest {
  return CheckpointManifestSchema.parse(manifest) as CheckpointManifest;
}

/**
 * Create a partial checkpoint manifest for building incrementally.
 * Useful when constructing a manifest step by step.
 *
 * @returns A Zod schema that allows partial fields
 */
export function createPartialCheckpointManifestSchema() {
  return CheckpointManifestSchema.partial();
}
